---
phase: 02-velite-implementation
plan: 02
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - app/[locale]/blog/page.tsx
  - app/[locale]/blog/[slug]/page.tsx
  - app/[locale]/blog/[slug]/mdx-content.tsx
  - package.json
autonomous: true

must_haves:
  truths:
    - "Blog listing page displays posts from Velite"
    - "Blog post page renders MDX content from Velite"
    - "Locale filtering works correctly (en posts for en, he posts for he)"
    - "Reading time displays on post pages"
    - "contentlayer2 is completely removed"
  artifacts:
    - path: "app/[locale]/blog/page.tsx"
      provides: "Blog listing using Velite data"
      contains: "import.*\\.velite"
    - path: "app/[locale]/blog/[slug]/page.tsx"
      provides: "Blog post page using Velite data"
      contains: "import.*\\.velite"
    - path: "app/[locale]/blog/[slug]/mdx-content.tsx"
      provides: "MDX rendering component for Velite output"
      contains: "useMDXComponent"
  key_links:
    - from: "app/[locale]/blog/page.tsx"
      to: ".velite"
      via: "import posts"
      pattern: "import.*posts.*\\.velite"
    - from: "app/[locale]/blog/[slug]/page.tsx"
      to: ".velite"
      via: "import posts"
      pattern: "import.*posts.*\\.velite"
    - from: "app/[locale]/blog/[slug]/mdx-content.tsx"
      to: "post.content"
      via: "useMDXComponent hook"
      pattern: "useMDXComponent"
---

<objective>
Update blog pages to use Velite-generated content and remove contentlayer2.

Purpose: Complete the migration from contentlayer2 to Velite by updating all blog pages to import from `.velite` and rendering MDX content correctly with the new format.

Output: Fully functional blog system powered by Velite with contentlayer2 completely removed from the project.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-velite-implementation/02-RESEARCH.md

Depends on Plan 02-01 which created:
- velite.config.ts with Post schema
- .velite directory with generated types and data
- Updated next.config.ts and tsconfig.json

Existing blog files to update:
@app/[locale]/blog/page.tsx
@app/[locale]/blog/[slug]/page.tsx
@app/[locale]/blog/[slug]/mdx-content.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update MDX content component for Velite output</name>
  <files>
    - app/[locale]/blog/[slug]/mdx-content.tsx
  </files>
  <action>
Replace the existing MDXContent component with one that renders Velite's compiled MDX output.

Velite compiles MDX to a function string that needs to be evaluated with react/jsx-runtime. The research doc provides the exact pattern.

Update `app/[locale]/blog/[slug]/mdx-content.tsx`:

```tsx
'use client'

import * as runtime from 'react/jsx-runtime'

interface MDXContentProps {
  code: string
  locale: string
}

/**
 * Hook to create MDX component from Velite-compiled code
 * Velite compiles MDX to a function string that exports a default component
 */
const useMDXComponent = (code: string) => {
  const fn = new Function(code)
  return fn({ ...runtime }).default
}

/**
 * Client Component for rendering Velite-compiled MDX content
 * Receives the compiled code string from Velite's s.mdx() output
 */
export function MDXContent({ code, locale }: MDXContentProps) {
  const Component = useMDXComponent(code)

  return (
    <div
      className="prose prose-invert prose-lg max-w-none
        prose-headings:font-bold prose-headings:text-white
        prose-h2:text-3xl prose-h2:mt-12 prose-h2:mb-6
        prose-h3:text-2xl prose-h3:mt-8 prose-h3:mb-4
        prose-p:text-neutral-300 prose-p:leading-relaxed prose-p:mb-6
        prose-a:text-blue-400 prose-a:no-underline hover:prose-a:text-blue-300
        prose-strong:text-white prose-strong:font-semibold
        prose-code:text-blue-400 prose-code:bg-blue-500/10 prose-code:px-2 prose-code:py-1 prose-code:rounded prose-code:before:content-none prose-code:after:content-none
        prose-pre:bg-neutral-900 prose-pre:border prose-pre:border-neutral-800 prose-pre:rounded-xl prose-pre:shadow-xl
        prose-ul:text-neutral-300 prose-ul:my-6
        prose-ol:text-neutral-300 prose-ol:my-6
        prose-li:my-2
        prose-blockquote:border-l-4 prose-blockquote:border-blue-500 prose-blockquote:pl-6 prose-blockquote:italic prose-blockquote:text-neutral-400
        prose-img:rounded-xl prose-img:shadow-2xl"
      dir={locale === "he" ? "rtl" : "ltr"}
    >
      <Component />
    </div>
  )
}
```

Key changes:
- REMOVE `ReactMarkdown` import and `remarkGfm` - Velite already compiles MDX
- REMOVE `getLocalizedContent` function - no longer needed with separate locale files
- ADD `useMDXComponent` hook that evaluates Velite's compiled code string
- CHANGE prop from `content: string` to `code: string` (Velite's output)
- Preserve all existing prose styling classes
- Keep RTL/LTR direction based on locale
  </action>
  <verify>
    - TypeScript compiles without errors
    - Component exports MDXContent function
    - No ReactMarkdown imports remain
  </verify>
  <done>
    - MDXContent component updated to render Velite-compiled MDX
    - useMDXComponent hook evaluates code string with jsx-runtime
    - All prose styling preserved
    - RTL/LTR direction handling preserved
  </done>
</task>

<task type="auto">
  <name>Task 2: Update blog pages to use Velite imports</name>
  <files>
    - app/[locale]/blog/page.tsx
    - app/[locale]/blog/[slug]/page.tsx
  </files>
  <action>
Update both blog pages to import from `.velite` instead of `contentlayer/generated`.

**1. Update `app/[locale]/blog/page.tsx`:**

```tsx
"use client";

import React, { useState, useCallback, useRef, useMemo, useEffect } from "react";
import { useSearchParams, useRouter, usePathname } from "next/navigation";
import { posts } from "@/.velite";
import Navigation from "@/components/sections/Navigation";
import Footer from "@/components/sections/Footer";
import { EffectsWrapper } from "@/components/effects/EffectsWrapper";
import { ThreeBackgroundWrapper } from "@/components/effects/ThreeBackgroundWrapper";
import {
  BlogHero,
  BlogFilters,
  BlogGrid,
  type BlogPost,
} from "@/components/sections/blog";

type Props = {
  params: Promise<{ locale: string }>;
};

/**
 * Transform Velite posts to BlogPost interface with locale filtering
 * Posts are already locale-specific from Velite (separate en.mdx/he.mdx files)
 */
function transformPosts(locale: string): BlogPost[] {
  return posts
    .filter((post) => post.locale === locale && post.published)
    .map((post) => ({
      id: post.slug,
      title: post.title,
      excerpt: post.excerpt,
      thumbnail: undefined, // TODO: Add thumbnail support in Phase 3
      author: {
        name: post.author,
        avatar: undefined, // TODO: Add author avatar support in Phase 3
      },
      date: post.date,
      category: post.category,
      slug: post.slug,
    }))
    .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
}

export default function BlogPage({ params }: Props) {
  const { locale } = React.use(params);

  // Transform Velite posts to BlogPost interface (now locale-filtered)
  const blogPosts = useMemo(() => transformPosts(locale), [locale]);

  // URL params for shareable filtered views
  const searchParams = useSearchParams();
  const router = useRouter();
  const pathname = usePathname();

  // State management for filters
  const [activeCategory, setActiveCategory] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState("");
  const [debouncedSearch, setDebouncedSearch] = useState("");
  const debounceRef = useRef<NodeJS.Timeout | null>(null);

  // Initialize filters from URL params
  useEffect(() => {
    const category = searchParams.get("category");
    const search = searchParams.get("q");
    if (category) setActiveCategory(category);
    if (search) {
      setSearchQuery(search);
      setDebouncedSearch(search);
    }
  }, [searchParams]);

  // Sync filters to URL params
  useEffect(() => {
    const params = new URLSearchParams();
    if (activeCategory) params.set("category", activeCategory);
    if (debouncedSearch) params.set("q", debouncedSearch);

    const queryString = params.toString();
    router.replace(
      queryString ? `${pathname}?${queryString}` : pathname,
      { scroll: false }
    );
  }, [activeCategory, debouncedSearch, pathname, router]);

  // Derive unique categories from filtered posts
  const categories = Array.from(
    new Set(blogPosts.map((post) => post.category))
  ).sort();

  // Debounced search handler
  const handleSearchChange = useCallback((query: string) => {
    setSearchQuery(query);

    if (debounceRef.current) {
      clearTimeout(debounceRef.current);
    }
    debounceRef.current = setTimeout(() => {
      setDebouncedSearch(query);
    }, 300);
  }, []);

  // Cleanup debounce timeout on unmount
  useEffect(() => {
    return () => {
      if (debounceRef.current) {
        clearTimeout(debounceRef.current);
      }
    };
  }, []);

  // Category change handler
  const handleCategoryChange = useCallback((category: string | null) => {
    setActiveCategory(category);
  }, []);

  // Filter logic with memoization
  const filteredPosts = useMemo(() => {
    return blogPosts.filter((post) => {
      const matchesCategory =
        activeCategory === null || post.category === activeCategory;

      const searchLower = debouncedSearch.toLowerCase();
      const matchesSearch =
        debouncedSearch === "" ||
        post.title.toLowerCase().includes(searchLower) ||
        post.excerpt.toLowerCase().includes(searchLower);

      return matchesCategory && matchesSearch;
    });
  }, [blogPosts, activeCategory, debouncedSearch]);

  return (
    <main className="min-h-screen relative selection:bg-blue-500/30 selection:text-white">
      <EffectsWrapper />
      <ThreeBackgroundWrapper />
      <Navigation />
      <BlogHero />
      <BlogFilters
        categories={categories}
        activeCategory={activeCategory}
        searchQuery={searchQuery}
        onCategoryChange={handleCategoryChange}
        onSearchChange={handleSearchChange}
      />
      <BlogGrid posts={filteredPosts} locale={locale} />
      <Footer />
    </main>
  );
}
```

Key changes:
- CHANGE import from `contentlayer/generated` to `@/.velite`
- CHANGE `allPosts` to `posts` (Velite's export name)
- SIMPLIFY `transformPosts` - no more `_he` suffix handling, posts are already locale-specific
- ADD locale filter: `post.locale === locale`
- REMOVE `title_he`, `excerpt_he`, `category_he` logic - no longer needed
- Note: thumbnail and authorAvatar set to undefined for now (Phase 3 will add author profiles)

**2. Update `app/[locale]/blog/[slug]/page.tsx`:**

```tsx
import { posts } from "@/.velite";
import { notFound } from "next/navigation";
import type { Metadata } from "next";
import Navigation from "@/components/sections/Navigation";
import Footer from "@/components/sections/Footer";
import { EffectsWrapper } from "@/components/effects/EffectsWrapper";
import { ThreeBackgroundWrapper } from "@/components/effects/ThreeBackgroundWrapper";
import { MDXContent } from "./mdx-content";
import {
  getArticleSchema,
  getBreadcrumbSchema,
  getFAQSchema,
  jsonLdScriptProps,
} from "@/lib/schema";

// FAQ data for MVP article (for featured snippets)
const mvpFaqsHe = [
  {
    question: "כמה זמן לוקח לפתח MVP?",
    answer: "4-8 שבועות למרבית הפרויקטים. MVP פשוט (לנדינג פייג' + טופס) לוקח 1-2 שבועות, MVP סטנדרטי (אפליקציית web) לוקח 4-6 שבועות, ו-MVP מורכב עם אינטגרציות רבות לוקח 8-12 שבועות.",
  },
  {
    question: "כמה עולה לפתח MVP?",
    answer: "טווח המחירים בישראל: לנדינג פייג' ואימות עולה ₪8,000-₪15,000, אפליקציית web בסיסית עולה ₪30,000-₪80,000, ו-MVP מלא עם אפליקציה עולה ₪80,000-₪180,000. MVP טוב חוסך 60-70% מעלות פיתוח מוצר מלא.",
  },
  {
    question: "האם אני צריך להיות טכני כדי לבנות MVP?",
    answer: "לא. אתם צריכים להבין את הלקוחות ואת הבעיה. מה שצריך: ראייה ברורה של מה המוצר עושה, יכולת לתקשר את החזון, זמן להיות מעורב בתהליך, ושותף טכני או חברת פיתוח שאתם סומכים עליהם.",
  },
  {
    question: "מה ההבדל בין MVP לאבטיפוס?",
    answer: "אבטיפוס = הדגמה. MVP = מוצר אמיתי, מינימלי. אבטיפוס מיועד להדגים רעיון למשקיעים או צוות עם פונקציונליות מוגבלת, בעוד MVP מיועד לבדוק שוק עם לקוחות אמיתיים ופונקציונליות אמיתית.",
  },
  {
    question: "איך אני יודע אם ה-MVP שלי מצליח?",
    answer: "מדדים קריטיים: Activation Rate (כמה משתמשים משלימים פעולה ראשונה), Retention (כמה חוזרים אחרי שבוע/חודש), NPS (האם ממליצים לחברים), Conversion (כמה עוברים לתשלום), ו-Engagement. אם 40%+ מהמשתמשים יהיו מאוכזבים מאוד אם המוצר ייעלם - אתם על הדרך הנכונה.",
  },
  {
    question: "מה עושים אחרי השקת ה-MVP?",
    answer: "3 מסלולים אפשריים: Scale (הרחבה) - אם המוצר עובד, הוסיפו תכונות ושיווק; Iterate (שיפור) - אם הכיוון נכון אבל צריך שיפורים; Pivot (שינוי כיוון) - אם הרעיון המקורי לא עובד. תמיד נתחו את הנתונים ודברו עם משתמשים לפני ההחלטה.",
  },
];

const mvpFaqsEn = [
  {
    question: "How long does it take to develop an MVP?",
    answer: "4-8 weeks for most projects. A simple MVP (landing page + form) takes 1-2 weeks, a standard MVP (basic web application) takes 4-6 weeks, and a complex MVP with many integrations takes 8-12 weeks.",
  },
  {
    question: "How much does it cost to develop an MVP?",
    answer: "Price ranges: Landing page + validation costs $2,000-$5,000, basic web application costs $8,000-$25,000, and full MVP with mobile app costs $25,000-$50,000. A good MVP saves 60-70% of full product development costs.",
  },
  {
    question: "Do I need to be technical to build an MVP?",
    answer: "No. You need to understand your customers and the problem. What you do need: clear vision of what the product does, ability to communicate the vision, time to be involved in the process, and a technical partner or development company you trust.",
  },
  {
    question: "What's the difference between an MVP and a Prototype?",
    answer: "Prototype = demonstration. MVP = real product, minimal. A prototype is meant to demonstrate an idea to investors or team with limited functionality, while an MVP is meant to test the market with real customers and real functionality.",
  },
  {
    question: "How do I know if my MVP is successful?",
    answer: "Critical metrics: Activation Rate (how many users complete a first action), Retention (how many return after a week/month), NPS (would they recommend to friends), Conversion (how many go from free to paid), and Engagement. If 40%+ of users would be very disappointed if the product disappeared - you're on the right track.",
  },
  {
    question: "What do you do after launching the MVP?",
    answer: "3 possible paths: Scale - if the product works, add features and marketing; Iterate - if direction is right but needs improvements; Pivot - if the original idea doesn't work. Always analyze the data and talk to users before deciding.",
  },
];

const BASE_URL = "https://kohelet.digital";

interface Props {
  params: Promise<{
    locale: string;
    slug: string;
  }>;
}

/**
 * Generate static params for all blog posts
 * Generate for both locales since posts are now separate per locale
 */
export async function generateStaticParams() {
  return posts
    .filter((post) => post.published)
    .map((post) => ({
      locale: post.locale,
      slug: post.slug,
    }));
}

/**
 * Generate SEO metadata for the blog post
 */
export async function generateMetadata({ params }: Props): Promise<Metadata> {
  const { locale, slug } = await params;
  const post = posts.find((p) => p.slug === slug && p.locale === locale);

  if (!post) {
    return {
      title: "Post Not Found",
      description: "The requested blog post could not be found.",
    };
  }

  return {
    title: post.title,
    description: post.excerpt,
    openGraph: {
      title: post.title,
      description: post.excerpt,
      type: "article",
      publishedTime: post.date,
      authors: [post.author],
    },
    twitter: {
      card: "summary_large_image",
      title: post.title,
      description: post.excerpt,
    },
  };
}

/**
 * Blog Post Page Component
 * Renders individual blog post with MDX content from Velite
 */
export default async function BlogPostPage({ params }: Props) {
  const { locale, slug } = await params;

  // Find the post by slug AND locale (posts are now locale-specific)
  const post = posts.find((p) => p.slug === slug && p.locale === locale);

  // Handle 404 - post not found or not published
  if (!post || !post.published) {
    notFound();
  }

  // Format date for display
  const formattedDate = new Date(post.date).toLocaleDateString(
    locale === "he" ? "he-IL" : "en-US",
    {
      year: "numeric",
      month: "long",
      day: "numeric",
    }
  );

  // Generate structured data for SEO and AI engines
  const articleSchema = getArticleSchema({
    title: post.title,
    description: post.excerpt,
    url: `${BASE_URL}/${locale}/blog/${post.slug}`,
    datePublished: post.date,
    author: post.author,
    image: undefined, // TODO: Add thumbnail support in Phase 3
    locale,
  });

  const breadcrumbSchema = getBreadcrumbSchema([
    { name: locale === "he" ? "דף הבית" : "Home", url: `${BASE_URL}/${locale}` },
    { name: locale === "he" ? "בלוג" : "Blog", url: `${BASE_URL}/${locale}/blog` },
    { name: post.title, url: `${BASE_URL}/${locale}/blog/${post.slug}` },
  ]);

  // Add FAQ schema for articles with FAQs (MVP article)
  const schemas: object[] = [articleSchema, breadcrumbSchema];
  if (slug === "mvp-4-week-sprint-guide") {
    const faqSchema = getFAQSchema(locale === "he" ? mvpFaqsHe : mvpFaqsEn);
    schemas.push(faqSchema);
  }

  return (
    <main className="min-h-screen relative selection:bg-blue-500/30 selection:text-white">
      <script {...jsonLdScriptProps(schemas)} />
      <EffectsWrapper />
      <ThreeBackgroundWrapper />
      <Navigation />

      <article className="relative z-10 pt-32 pb-20">
        <div className="container max-w-4xl mx-auto px-6">
          {/* Post Header */}
          <header className="mb-12">
            {/* Category Badge */}
            <div className="mb-6">
              <span className="inline-block px-4 py-2 rounded-full text-sm font-medium bg-blue-500/10 text-blue-400 border border-blue-500/20">
                {post.category}
              </span>
            </div>

            {/* Title */}
            <h1 className="text-4xl md:text-5xl lg:text-6xl font-bold mb-6 text-white leading-tight">
              {post.title}
            </h1>

            {/* Meta Information */}
            <div className="flex items-center gap-4 text-neutral-400">
              <div className="flex flex-col sm:flex-row sm:items-center sm:gap-4">
                <span className="font-medium text-white">{post.author}</span>
                <span className="hidden sm:inline text-neutral-600">•</span>
                <time dateTime={post.date} className="text-sm">
                  {formattedDate}
                </time>
                <span className="hidden sm:inline text-neutral-600">•</span>
                <span className="text-sm">
                  {post.metadata.readingTime} {locale === "he" ? "דקות קריאה" : "min read"}
                </span>
              </div>
            </div>
          </header>

          {/* MDX Content - now using Velite's compiled output */}
          <MDXContent code={post.content} locale={locale} />
        </div>
      </article>

      <Footer />
    </main>
  );
}
```

Key changes:
- CHANGE import from `contentlayer/generated` to `@/.velite`
- CHANGE `allPosts` to `posts`
- CHANGE post lookup to include locale: `p.slug === slug && p.locale === locale`
- CHANGE `generateStaticParams` to include locale in params (both en and he)
- REMOVE all `_he` suffix handling - posts are now locale-specific
- REMOVE thumbnail/authorAvatar references (Phase 3 scope)
- ADD reading time display using `post.metadata.readingTime`
- CHANGE MDXContent prop from `content={post.body.raw}` to `code={post.content}`
  </action>
  <verify>
    - Run `npm run dev` and verify:
      - `/en/blog` shows English posts only
      - `/he/blog` shows Hebrew posts only
      - Clicking a post opens the full article
      - MDX content renders correctly with all formatting
      - Reading time displays on post pages
    - Run `npm run build` and verify no TypeScript errors
  </verify>
  <done>
    - Blog listing page imports from .velite and filters by locale
    - Blog post page imports from .velite and renders MDX content
    - Reading time displays on post pages
    - All locale filtering works correctly
  </done>
</task>

<task type="auto">
  <name>Task 3: Remove contentlayer2 and cleanup</name>
  <files>
    - package.json
    - contentlayer.config.ts (delete)
    - tsconfig.json
  </files>
  <action>
1. Uninstall contentlayer2 packages:
   ```bash
   npm uninstall contentlayer2 next-contentlayer2
   ```

2. Delete contentlayer config file:
   ```bash
   rm contentlayer.config.ts
   ```

3. Remove contentlayer script from package.json scripts (if exists):
   - Remove `"contentlayer": "contentlayer2 build"` from scripts

4. Verify tsconfig.json no longer has contentlayer paths (should already be updated from Plan 01):
   - Should NOT contain `"contentlayer/generated"` in paths
   - Should NOT contain `.contentlayer/generated` in include

5. Clean up any .contentlayer directory if it exists:
   ```bash
   rm -rf .contentlayer
   ```
  </action>
  <verify>
    - `npm ls contentlayer2` shows "empty"
    - `npm ls next-contentlayer2` shows "empty"
    - `contentlayer.config.ts` does not exist
    - `.contentlayer` directory does not exist
    - `npm run build` completes successfully
    - `npm run dev` starts without errors
  </verify>
  <done>
    - contentlayer2 and next-contentlayer2 packages uninstalled
    - contentlayer.config.ts deleted
    - .contentlayer directory removed
    - No contentlayer references remain in codebase
    - Build completes without contentlayer
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Blog listing works:**
   - Visit `/en/blog` - shows English posts only
   - Visit `/he/blog` - shows Hebrew posts only
   - Categories filter correctly
   - Search filters correctly

2. **Blog posts render:**
   - Visit `/en/blog/mvp-4-week-sprint-guide` - renders English content
   - Visit `/he/blog/mvp-4-week-sprint-guide` - renders Hebrew content
   - MDX formatting (headings, code blocks, lists, blockquotes) renders correctly
   - Reading time displays

3. **Build succeeds:**
   ```bash
   npm run build
   ```
   - No TypeScript errors
   - No contentlayer references
   - Velite processes all 10 MDX files (5 posts x 2 locales)

4. **Clean dependencies:**
   ```bash
   npm ls | grep contentlayer
   ```
   - Should return nothing

5. **Production test:**
   ```bash
   npm run build && npm run start
   ```
   - Blog pages work in production mode
</verification>

<success_criteria>
- [ ] Blog listing page displays posts filtered by current locale
- [ ] Blog post page renders MDX content correctly
- [ ] Reading time displays on post pages
- [ ] Hebrew content renders RTL, English renders LTR
- [ ] contentlayer2 packages completely removed
- [ ] contentlayer.config.ts deleted
- [ ] No contentlayer imports remain in codebase
- [ ] `npm run build` succeeds without errors
- [ ] `npm run dev` starts without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-velite-implementation/02-02-SUMMARY.md`
</output>
