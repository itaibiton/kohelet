---
phase: 02-velite-implementation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - velite.config.ts
  - next.config.ts
  - tsconfig.json
  - .gitignore
autonomous: true

must_haves:
  truths:
    - "Velite successfully compiles all MDX files at build time"
    - "TypeScript types are auto-generated from frontmatter schema"
    - "Reading time is computed automatically for each post"
    - "Slug is derived from folder name consistently"
  artifacts:
    - path: "velite.config.ts"
      provides: "Velite configuration with bilingual schema"
      contains: "defineCollection"
    - path: "next.config.ts"
      provides: "Velite programmatic API integration"
      contains: "velite"
    - path: "tsconfig.json"
      provides: "TypeScript paths for .velite imports"
      contains: ".velite"
    - path: ".velite/index.d.ts"
      provides: "Auto-generated TypeScript types"
  key_links:
    - from: "next.config.ts"
      to: "velite"
      via: "programmatic API import"
      pattern: "import.*velite"
    - from: "velite.config.ts"
      to: "content/blog/**/*.mdx"
      via: "pattern matching"
      pattern: "blog/\\*\\*/\\*.mdx"
---

<objective>
Install and configure Velite to replace contentlayer2 as the MDX content processor.

Purpose: Establish Velite build infrastructure that processes the existing bilingual MDX content structure (en.mdx/he.mdx per folder) and generates type-safe content for the blog.

Output: Working Velite configuration that compiles MDX files at build time with automatic reading time calculation, slug extraction from folder names, and locale extraction from filenames.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-velite-implementation/02-RESEARCH.md

Existing files to modify:
@next.config.ts
@tsconfig.json
@package.json
@.gitignore
@contentlayer.config.ts (reference for schema)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Velite dependencies and create configuration</name>
  <files>
    - package.json
    - velite.config.ts
    - .gitignore
  </files>
  <action>
1. Install packages:
   ```bash
   npm install velite zod
   ```

2. Create `velite.config.ts` in project root with this schema:

```typescript
import { defineConfig, defineCollection, s } from 'velite'
import rehypeSlug from 'rehype-slug'
import rehypeAutolinkHeadings from 'rehype-autolink-headings'
import rehypeHighlight from 'rehype-highlight'
import remarkGfm from 'remark-gfm'

const posts = defineCollection({
  name: 'Post',
  pattern: 'blog/**/*.mdx',
  schema: s
    .object({
      title: s.string().max(200),
      excerpt: s.string().max(1000),
      date: s.isodate(),
      author: s.string(),
      category: s.string(),
      published: s.boolean().default(true),
      needsTranslation: s.boolean().optional(),
      metadata: s.metadata(), // Auto-generates readingTime & wordCount
      content: s.mdx(),
    })
    .transform((data, { meta }) => {
      // Extract slug from folder name and locale from filename
      // meta.path = "blog/mvp-4-week-sprint-guide/en.mdx"
      const pathParts = meta.path.split('/')
      const fileName = pathParts[pathParts.length - 1] // "en.mdx"
      const folderName = pathParts[pathParts.length - 2] // "mvp-4-week-sprint-guide"
      const locale = fileName.replace('.mdx', '') as 'en' | 'he'

      return {
        ...data,
        slug: folderName,
        locale,
        url: `/${locale}/blog/${folderName}`,
      }
    }),
})

export default defineConfig({
  root: 'content',
  output: {
    data: '.velite',
    assets: 'public/static',
    base: '/static/',
    name: '[name]-[hash:6].[ext]',
    clean: true,
  },
  collections: { posts },
  mdx: {
    remarkPlugins: [remarkGfm],
    rehypePlugins: [
      rehypeSlug,
      [rehypeAutolinkHeadings, { behavior: 'wrap' }],
      rehypeHighlight,
    ],
  },
})
```

Key decisions:
- Use `s.metadata()` for automatic reading time calculation (not hand-rolled)
- Extract slug from folder name and locale from filename via transform
- Keep existing rehype plugins (rehype-highlight, rehype-slug, rehype-autolink-headings)
- Use `content` as root (not `content/blog`) since pattern starts with `blog/`

3. Add to `.gitignore`:
   ```
   # Velite generated files
   .velite
   ```

Note: Do NOT remove contentlayer2 yet - that happens in Plan 02 after blog pages are updated.
  </action>
  <verify>
    - `npm ls velite zod` shows both packages installed
    - `velite.config.ts` exists and exports a valid config
    - `.gitignore` includes `.velite`
  </verify>
  <done>
    - Velite and zod packages installed
    - velite.config.ts created with bilingual schema matching existing frontmatter
    - .gitignore updated to exclude .velite directory
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate Velite with Next.js and TypeScript</name>
  <files>
    - next.config.ts
    - tsconfig.json
  </files>
  <action>
1. Update `next.config.ts` to use Velite's programmatic API (Turbopack-compatible):

```typescript
import type { NextConfig } from "next";
import createNextIntlPlugin from "next-intl/plugin";
import bundleAnalyzer from "@next/bundle-analyzer";

const withNextIntl = createNextIntlPlugin("./i18n/request.ts");
const withBundleAnalyzer = bundleAnalyzer({
  enabled: process.env.ANALYZE === "true",
});

// Velite integration for Turbopack (programmatic API, NOT webpack plugin)
const isDev = process.argv.includes('dev')
const isBuild = process.argv.includes('build')
if (!process.env.VELITE_STARTED && (isDev || isBuild)) {
  process.env.VELITE_STARTED = '1'
  const { build } = await import('velite')
  await build({ watch: isDev, clean: !isDev })
}

const nextConfig: NextConfig = {
  // Image optimization
  images: {
    formats: ["image/avif", "image/webp"],
    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048],
    imageSizes: [16, 32, 48, 64, 96, 128, 256],
    minimumCacheTTL: 60 * 60 * 24 * 30, // 30 days
  },

  // Security and caching headers
  headers: async () => [
    {
      source: "/:path*",
      headers: [
        {
          key: "X-DNS-Prefetch-Control",
          value: "on",
        },
        {
          key: "X-Content-Type-Options",
          value: "nosniff",
        },
        {
          key: "Referrer-Policy",
          value: "strict-origin-when-cross-origin",
        },
        {
          key: "Permissions-Policy",
          value: "camera=(), microphone=(), geolocation=()",
        },
      ],
    },
    {
      source: "/:all*(svg|jpg|jpeg|png|gif|ico|webp|avif|woff|woff2|ttf|eot)",
      headers: [
        {
          key: "Cache-Control",
          value: "public, max-age=31536000, immutable",
        },
      ],
    },
    {
      source: "/_next/static/:path*",
      headers: [
        {
          key: "Cache-Control",
          value: "public, max-age=31536000, immutable",
        },
      ],
    },
  ],

  // Experimental performance optimizations
  experimental: {
    optimizeCss: true,
    largePageDataBytes: 128 * 1024,
  },

  // Logging configuration
  logging: {
    fetches: {
      fullUrl: process.env.NODE_ENV === "development",
    },
  },
};

// Note: withContentlayer removed - Velite uses programmatic API above
export default withBundleAnalyzer(withNextIntl(nextConfig));
```

Key changes:
- REMOVE `withContentlayer` wrapper import and usage
- ADD Velite programmatic build at top level (uses top-level await)
- Use `process.argv.includes()` for cleaner detection of dev/build mode
- Set `watch: isDev` for hot reload in development
- Set `clean: !isDev` to clean on production builds only

2. Update `tsconfig.json` to add .velite paths:

```json
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [{ "name": "next" }],
    "paths": {
      "@/*": ["./*"],
      ".velite": ["./.velite"]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts",
    ".velite"
  ],
  "exclude": ["node_modules"]
}
```

Key changes:
- REPLACE `"contentlayer/generated": ["./.contentlayer/generated"]` with `".velite": ["./.velite"]`
- REPLACE `.contentlayer/generated` in include array with `.velite`
  </action>
  <verify>
    - Run `npm run build` and verify:
      - Velite compilation output shows (processing MDX files)
      - `.velite` directory is created
      - `.velite/index.d.ts` contains Post type
      - Build completes without contentlayer errors
    - Run `npm run dev` and verify:
      - Velite builds and watches
      - No webpack plugin errors (Turbopack compatible)
  </verify>
  <done>
    - next.config.ts uses Velite programmatic API (not webpack plugin)
    - tsconfig.json has .velite path alias
    - `npm run build` successfully compiles MDX files via Velite
    - `.velite` directory contains generated types and data
  </done>
</task>

</tasks>

<verification>
After completing both tasks:

1. **Velite builds successfully:**
   ```bash
   npm run build
   ```
   - Should see Velite processing messages
   - Should create `.velite/` directory with:
     - `index.js` (ESM exports)
     - `index.d.ts` (TypeScript types)
     - Post data for all 10 MDX files (5 posts x 2 locales)

2. **TypeScript types generated:**
   ```bash
   cat .velite/index.d.ts
   ```
   - Should contain `Post` type with all frontmatter fields
   - Should include computed fields: `slug`, `locale`, `url`, `metadata`

3. **Reading time computed:**
   ```bash
   cat .velite/posts.json | head -50
   ```
   - Each post should have `metadata.readingTime` field

4. **No contentlayer errors:**
   - Build should not mention contentlayer (even though packages still installed)
   - No webpack plugin errors with Turbopack
</verification>

<success_criteria>
- [ ] `npm run build` completes without errors
- [ ] `.velite` directory created with generated files
- [ ] Post type includes: title, excerpt, date, author, category, published, slug, locale, url, metadata
- [ ] `metadata.readingTime` is populated for each post
- [ ] Slugs match folder names (e.g., "mvp-4-week-sprint-guide")
- [ ] Locales are "en" or "he" based on filename
- [ ] No Turbopack/webpack compatibility errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-velite-implementation/02-01-SUMMARY.md`
</output>
